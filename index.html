<!DOCTYPE html>
<!--[if IE 7 | IE 8]>
<html class="ie" dir="ltr" lang="en">
<![endif]-->
<!--[if !(IE 7) | !(IE 8)  ]><!-->
<html dir="ltr" lang="en">
<!--<![endif]-->
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width"/>
  <meta name="robots" content="noindex,nofollow"/>
  <meta name="generator" content="markpress"/>
  <meta name="description" content="Home"/>
  <meta property="og:type" content="blog"/>
  <meta property="og:title" content="随便想想"/>
  <meta property="og:url" content="http://blog.xiao-jia.com"/>
  <meta property="og:description" content="Home"/>
  <meta property="og:site_name" content="随便想想"/>
  <title>Home &middot; 随便想想</title>
  <!--[if lt IE 9]>
  <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link rel="stylesheet" id="fonts-css" href="http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,400,700" type="text/css" media="all"/>
  <link rel="stylesheet" id="all-css" href="http://blog.xiao-jia.com/style.min.css" type="text/css" media="all"/>
  <link rel="alternate" type="application/atom+xml" title="随便想想" href="http://blog.xiao-jia.com/atom.xml"/>
</head>
<body class="blog">
  <div id="page" class="hfeed site">
    <header id="masthead" class="site-header" role="banner">
      <hgroup>
        <h1 class="site-title"><a href="http://blog.xiao-jia.com" title="随便想想" rel="home">随便想想</a></h1>
        <!--<h2 class="site-description"></h2>-->
      </hgroup>
      <nav id="site-navigation" class="main-navigation" role="navigation">
        <h3 class="menu-toggle">Menu</h3>
        <div class="skip-link assistive-text">
          <a href="#content" title="Skip to content">Skip to content</a>
        </div>
        <div class="menu-main-menu-container">
          <ul id="menu-main-menu" class="nav-menu">
            <li class="menu-item menu-item-type-post_type menu-item-object-page">
              <a href="http://blog.xiao-jia.com">Home</a>
            </li>
            <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="http://blog.xiao-jia.com/about/"> About</a></li>
          </ul>
        </div>
      </nav><!-- #site-navigation -->
    </header><!-- #masthead -->
    <div id="main" class="wrapper">
      <div id="primary" class="site-content">
        <div id="content" role="main"><article class="post type-post status-publish format-standard hentry"><header class="entry-header"><h1 class="entry-title"><a href="http://blog.xiao-jia.com/2012/10/08/one-month-sg/" rel="bookmark"> @sg (2)</a></h1><a class="comments-link" href="http://blog.xiao-jia.com/2012/10/08/one-month-sg/#disqus_thread">Comments</a></header><div class="entry-content"><p>本来打算调完 bug 再写一篇来坡上一个月的文章，不过看目前的趋势，如果再不写，恐怕要等几周甚至一个月了。</p>

<p>听说上海已经进入了秋天，但坡上还是夏天的景象。今天和昨天没有丝毫的不同，偶尔会在半夜下大雨，但到了白天，温度仿佛一点都不变。这种没有四季更迭的地方，让人觉得生命毫无进展，特别是每天都在调 bug 又调不出来的时候。</p>

<p>今早上是人生第一次投递明信片。上周五的时候，以坑爹的会员价从学校里的书店买了好多明信片和邮票。周末除了吃饭睡觉打豆豆，剩下的时间就是在写明信片。以前觉得寄明信片这种事情啊，是文艺青年才干的，我这种 2B 青年丝毫没有觉得在有生之年会文艺一把。而且实在是缺乏文艺细胞，又长时间不写字，感觉整个周末过得特别崎岖不平。不管怎么样，最后还是写完了。有些人还没回复给我通讯地址，只能等下次再寄了 @.@</p>

<p>瞬间出现的思绪都写完了，下面开始记流水帐。</p>

<p>十月来临之前，匆匆忙忙把 PLDI 的程序写得差不多了，然后就开始调 bug。十月第一天，POPL 那篇被拒掉了，后来看了一眼录用的文章，感觉今年质量尤其突出啊，幸好被拒掉了不然太惭愧了。然后端正了一下态度，觉得不能为了赶会议而写程序、因为写了程序就要写论文。好不容易来世间走一遭，随随便便就写一篇自己都不满意的文章投出去，实在是太浪费绳命了。</p>

<p>调 bug 之余，除了睡觉，就是整理了一下个人主页。做个人主页这件事情，从小学做到今天，感觉总算有个样子。原因好像很简单，小时候没有什么能写的东西，内容不丰富。此番整理，大概把之前做过的、我觉得值得一提的东西，都列出来了。有些细节还没写，不过也不急。</p>

<p>整理好个人主页之后，突然觉得应该把小时候的“梦想”都努力实现一下，比如做游戏。小学四年级的时候玩《新剑侠情缘》，后来把《剑侠情缘》所有单机版的都玩了一遍。同样地，还有《仙剑奇侠传》系列。后来游戏玩腻了，就想自己做一个。机缘巧合，当时<a href="http://www.gpgame.net/">金点时空</a>正处鼎盛时期，网友之间的交流让我受益匪浅，我还把《圣剑英雄传》的代码全都打印下来看了好几遍。那段时间应该算我正式学习写程序，兴趣激发着看代码，提高很快。而且做游戏是一件很杂的事情，不仅要有引擎本身，图像、音乐也要有，所以顺带着熟悉了一些相关的工具。</p>

<p>现在回想起来，我学习编程最初的五六年，都是在近乎盲目地摸索。那个时候网络不发达，中文书籍也不多，英文资料又看不懂，很多东西都要靠自己试出来。现在不一样了，网络发达，资料丰富，英文也能看懂，所以学习起来就要方便很多。但我总觉得，现在学的很多东西，都不够本质，缺乏直观印象，学了也没有快感。我也经常看到很多人，学过的东西用不起来，之间的联系毫无感觉，不知道是不是“学习方便”造成的。</p>

<p>回到正题（假如有的话），现在又觉得想做个游戏了。当然问题有两个，一是没有好故事，二是没有好美工。进一步的问题是，两个或者更多人合作，特别是做游戏这种东西，一定要观念一样，要有认同感。从前认识过一些朋友，想一起做游戏，但目的多是为了学习、练习，以及丰富自己的经历和简历，都不是来“圆梦”的。这种情况下，我都没有激情来写代码，逼着自己写也没快感，所以都无疾而终。好故事很难找，恐怕只能自己编。《仙剑》的故事算是经典了，相比之下《剑侠情缘》就差很多。另一方面，线性的故事结构并不比小说好到哪去，游戏者参与的程度不够深入。之前很喜欢玩《刺客信条》，因为任务和剧情不是完全线性的，而是一个松散的偏序结构，这样我觉得就很好。美工的话，网上也能找到很多素材，或者可以重用经典游戏的素材，问题倒不是很大，就是苦力多一些。总而言之，如果有人不小心看到这篇文章的这一段，有相同的想法的话，欢迎和我联系。</p>

<p>最后，写着写着不困了，继续调 bug 去了。</p>

<hr />

<p>补记：今天上午来的早，赶上实验室一个外国女生过生日，于是吃了好多蛋糕，然后发现和他们笑点不太一样啊……</p>
</div><footer class="entry-meta">This entry was posted on <a href="http://blog.xiao-jia.com/2012/10/08/one-month-sg/" rel="bookmark"><time class="entry-date" pubdate>October 8, 2012</time></a><span class="by-author"> by <span class="author vcard"><a class="url fn n" href="http://blog.xiao-jia.com" rel="author">Xiao Jia</a></span></span>&nbsp;&middot;&nbsp;<a href="http://blog.xiao-jia.com/tag/singapore/">singapore</a>&nbsp;&middot;&nbsp;<a href="http://blog.xiao-jia.com/tag/life/">life</a>&nbsp;&middot;&nbsp;<a href="http://blog.xiao-jia.com/tag/game/">game</a></footer></article><article class="post type-post status-publish format-standard hentry"><header class="entry-header"><h1 class="entry-title"><a href="http://blog.xiao-jia.com/2012/09/21/liangalei-stories/" rel="bookmark"> 听阿磊讲故事</a></h1><a class="comments-link" href="http://blog.xiao-jia.com/2012/09/21/liangalei-stories/#disqus_thread">Comments</a></header><div class="entry-content"><p>一直以来，我坚持认为，大学里见到的这些老师，讲课最好的当属梁阿磊。今天一个偶然的机会，搜到了<a href="http://bbs.sjtu.edu.cn">饮水思源 BBS</a> 上的“听阿磊讲故事”，于是心血来潮，又 Google 良久，收获颇丰，在此整理成文，与大家分享。</p>

<hr />

<p>我当时考研究生，又觉得读研究生浪费。
我爸就这么跟我说，他说，“你现在有大学毕业这么个资本，现在南下去工作，去闯，就像是拿你的资本投资。如果你要读研究生，就是储蓄，把你的本金扩大，完了再去投资。”
所以读研跟工作不矛盾。
就好比你现在有一万，去炒股，能赚钱，但就赚个几千。
当你储够了五万、十万，去炒股，也能赚钱，赚的就比之前多很多。
所以路很多，不要钻牛角尖。
我觉得你们现在太看重工作了，争着要去一家好公司。
其实人生还长。
我昨天看十七大，那些中央的，都是闯过很多地方，什么先去甘肃啊，再去天津什么的，最后进了中央。
最重要的是什么呢，心要宽。
如果心不宽的话，就算把你放到一条好路上，你也走不好。
我以前做项目，很抠，抠经费啊，抠效率什么的。
现在项目做砸了也不要紧，不会觉得怎么样。
只是如果觉得项目能做成，我们要怎么样去把它做得最好，最优秀。</p>

<hr />

<p>我以前只看重学技术，一门心思学，这个想学，那个想学。
大学毕业后去了研究所，有一个高中同学，一起进去了。
他脑子很聪明，但不怎么学。
他问我，我怎么看你一直在看书，一直在学啊。
我说，我学得不多，觉得自己底气不足。
而他，就是学自己用到的，学得足够用了就好，其他时间用来玩。
……
后来陆续离开研究所，他去了顺德的一家银行。
我对他的行为有两点想不通。
第一，为什么不去深圳？当时南下，深圳最火嘛。
第二，为什么去银行，而不继续去搞技术。
后来想想，他心比我宽，现在和他失去联系了，但可以想象，他肯定过得比我好。</p>

<hr />

<p>对于我们普通人来说，思考是一件痛苦的事情。
因为我们每天都在思考，而思考的大多是很多很多琐事，生活上、学习上、工作上的琐事。
而对于比较高级的那种工程师来说，就不必为这样的琐事思考。
他们只需要思考专业领域比较顶尖的东西，我们要学会想他们那样思考。
思考的过程就是对已学知识的一个不断 polish 的过程。
就好比原本你拿到的是一块看上去很普通的石头，你把它磨啊磨，最后磨掉外壳，露出一块宝石，这个就是思考的结晶。</p>

<hr />

<p>原来我对新技术很有追求，听到有什么新的技术出来，就想马上去学。
结果呢，知道一点点，仅仅是了解点皮毛。
跟大多数人一样，学了一会儿就放在那里了，只知其然，不知其所以然。
一起讨论的时候，讲到 xx 技术，马上说，哦，这个我知道。
但是呢，要真要讲出个道道来，又讲不出。
现在呢，我只关心那些对我有切实帮助的，也需要用到的技术。
因为人的精力有限，要把精力花在对自身有提升的地方。</p>

<hr />

<p>（阿磊讲某个男生的故事）
他即将毕业的时候，没有向其他人一样忙于找工作。
他在做试验室一个防火墙项目的优化，而且是一个人做。
我跟他说，你怎么不去找工作，再晚的话，工作就没了。
他说，工作不要紧，总会有的，不急。
结果这个难题真的被他一个人啃掉了，把防火墙的带宽从 a GB 提高到了 b GB（具体数值忘了）。
然后去参加 xx 大会，展示这个成果。
原来只有 x 分钟的时间，破例让他讲了 y 分钟（具体数值也忘了）。
最后被在场的 Intel 的人看中了，去了 Intel 的 xx 部门（好像是做防火墙的）。
可惜这个部门几年前解散了，现在不知道他在哪里了。</p>

<hr />

<p>（在某节课上，阿磊深沉地说的一席话，把很多同学弄哭了。不记得原话，以下为转述。）</p>

<p>这个世界上，大多数人都是浑浑噩噩的过这一生。
有的，因为害怕自己那充满未知和危险的未来，而选择逃避；
有的一直在忙忙碌碌，在追寻着各种生活途径，回首前程，却发现自己已经迷失在了不断的追寻中；
有的却是简简单单，随波逐流，大多数人的选择，必是他的选择，大多数人的未来，却就是他的不明不白的未来。
会后悔吗？
是的，总归会有一个时刻，会猛然发觉，自己之前走过的路都是错的，并且诚心的祈祷，让这样的生活能够重新来过。
可是后悔了又如何，毕竟也从来没有明白过，到底什么才是自己的路，什么才是自己的真正的选择。</p>

<p>人是需要一个指路的明灯的，这可以是，一棵大树，一座灯塔，一颗星星。
至少在你今后的人生路上，你是坚定的向着那个方向前进的。
这个明灯不一定要能够到达，它的存在，只是让你知道，心里明确的知道，我不后悔，不会计较一时得失，不会贪恋路旁风景。
因为我所作的一切，都是在向着这个最终的目标前进的。
至少，你能够轻松的告诉自己，这就是我的真正的选择，于是就毅然的毫不动摇的走下去。</p>

<hr />

<p>（举例摘录）</p>

<p>解释异步和同步通讯的区别：</p>

<p>我六点从闵行乘校车去徐汇，和另一个老师说好在六百门口晚上七点等在那里，这个叫同步通讯。
如果说他要去购物，我到了就打电话给他，这个叫异步通讯。</p>

<p>解释时钟中断：</p>

<p>比如一个驾驶教练让学员联系，他如果上去就不下来了，也就是做了坏事，死循环了，教练有再大的权力也没有办法。
那么如果我只给他一升油，是不是用完了就停下来了？
这个就是时钟中断。
当然那个什么道高一尺魔高一丈，你把油箱戳破，自己灌油，就又可以开了。
现在大多数黑客，都是从修改时间中断长短，和修改中断指向的地址（改成指向他的代码）入手破坏的……</p>

<p>解释理论的重要性：</p>

<p>以前我只会实践。
读研的时候，有一个同学只懂理论，很多东西都没有看见过，很土的。
当时想要汉化 Turbo C，他把 BIOS 的代码都打印下来（比划了一下，大概有半米高）。
我看不懂，就从头开始看。
看了一个星期，就在资料室查资料搞懂什么意思，只看懂了一点引导区代码。
他不是的，他拿着打印的东西开始找，就找中断表。
因为一开始就确定技术路线改中断，然后找到就开始写了，大概两个月写出来了。
我最后也只看了十多页。为
什么他能这么快？
因为，尽管他新东西不懂，但是基本理论非常熟悉。
所以，你要知道你现在去看什么新技术，花了大量时间。
但是如果你懂理论你也许只需花十分之一的时间去弄懂它。 </p>

<p>关于流水线 pipeline 的解释：</p>

<p>比如打饭，一个学生打饭有几个步骤，打菜、打饭、打汤。
如果只有一个师傅服务，大家排队必然缓慢。
但是如果有三个师傅，分别负责三个步骤，这样效率就会提高。
或者不用 pipeline，用超标量 super-scalar，同样的例子就表示再建一个食堂。</p>

<p>关于需要培养逻辑的解释：</p>

<p>好比一台 P4 电脑没有网卡，386 加上网卡就比它有用；
或者说你不遵守 TCP/IP 协议，没有 IP 报头……只能在局域网中通讯，有了 IP 报头就能跨过路由。
就是说你说话需要条理性，否则通讯会比较有障碍。</p>

<p>关于 forwarding 的解释：</p>

<p>就好比我要给机械学院王老师一份文件，正常途径通过本院的吴老师记录和转送。
但是由于我和王老师很熟，我就直接给他了，然后再去登记。
（意思就是王老师可以不用等文件直接去做相关的事情）</p>

<p>关于为什么多周期的需要一个中间寄存器：</p>

<p>好比师傅盛菜，需要一个盘子，否则只能用勺把菜端在空中，那么一个指令分成多周期后，把指令存在每个中间寄存器中，是一个道理。</p>

<p>关于好的设计：</p>

<p>曾经要求设计一个根据打到靶上的激光强度测量距离。
由于是非线性的关系，所以自然地想到了去做一个求 log 的计算器，很困难。
后来想到一个好一点的办法，查表做，存入对应的数据，查就行了。
我当时的师父想出一个更绝的办法，他用地址记录强度，对应的数据作为距离。</p>

<hr />

<p>（关于课堂）</p>

<p>“用过XXX的同学举一下手，好，一，二&#8230;那知道XXX的同学举一下手，一，二，三&#8230;好，多了一些，那么我来说一下&#8230;&#8230;.”</p>

<p>“听懂的同学举一下手，好，一，二&#8230;（再讲）听懂的同学举一下手，一，二，三&#8230;好，多了一些，那么我来说一下&#8230;&#8230;.”</p>

<p>同学演讲完后，“我来说一下我对这位同学讲的东西的看法……”</p>

<hr />

<p>Martin Fowler 原来约好在交大讲座，却突然生病给送进了中山医院。
听说 Martin Fowler 前一天在西安，据我推测，他是在西安吃拉面吃坏了肚子……
（梁阿磊老师评语：这是软件工程在中国水土不服的具体表现。）</p>

<hr />

<p>（侧面叙述 1）</p>

<p>说2^6那年合肥学生运动搞的非常火，当时他也没什么心思学习，就想去加入闹一把革命。
后来找到当时他们学联的头头，说要加入学联。
头头叫他写一份思想汇报。
后来人家当着他的面就看了一眼汇报，然后给他安排了送热水的工作。
（梁：“这就是论文摘要没写好”）
于是后来追究责任的时候，因为只打了热水，就没算上他……</p>

<hr />

<p>（侧面叙述 2.1）</p>

<p>说他当初在41所，一个任务就是把HP的设备，开机 logo 换成41所的（自行联想，这两个挺像的）。
但是搞了很久没搞定，最后发现人家用了自修改代码……（然后开始讲自修改）</p>

<hr />

<p>（侧面叙述 2.2）</p>

<p>嗯，另一个版本是，把摩托罗拉的改成41所的。
展览会的时候，摩托罗拉的代表觉得和自己的设备好像啊，就按了几下，然后双峰就出来了……</p>

<hr />

<p>（侧面叙述 3）</p>

<p>讲高手不用复杂的工具，背景还是41所。
说有个老师傅，不用工具箱，只用螺丝刀和钳子。
有一天一块非常复杂的板子坏了，谁都不知道怎么回事，仪器也测不出来。
于是就请老师傅看一看。
老师傅站在板子前面盯着看，然后指了一下，说这儿短路了。
嗯，然后问题就解决了。</p>

<hr />

<p>（最后列几个我印象比较深的）</p>

<p>好的设计就是好的权衡。</p>

<p>（激励学生直接提问题）
不能带着问题听……
法庭不是法律课……</p>

<p>（还有一些，以后想起来再补充……）</p>
</div><footer class="entry-meta">This entry was posted on <a href="http://blog.xiao-jia.com/2012/09/21/liangalei-stories/" rel="bookmark"><time class="entry-date" pubdate>September 21, 2012</time></a><span class="by-author"> by <span class="author vcard"><a class="url fn n" href="http://blog.xiao-jia.com" rel="author">Xiao Jia</a></span></span>&nbsp;&middot;&nbsp;<a href="http://blog.xiao-jia.com/tag/好玩的/">好玩的</a>&nbsp;&middot;&nbsp;<a href="http://blog.xiao-jia.com/tag/故事/">故事</a></footer></article><article class="post type-post status-publish format-standard hentry"><header class="entry-header"><h1 class="entry-title"><a href="http://blog.xiao-jia.com/2012/09/17/two-weeks-sg/" rel="bookmark"> @sg (1)</a></h1><a class="comments-link" href="http://blog.xiao-jia.com/2012/09/17/two-weeks-sg/#disqus_thread">Comments</a></header><div class="entry-content"><p>不知不觉，来新加坡已经半个多月了。
也没有什么特别的感触；就好像上大学，到了一个新的地方，熟悉这里的生活，融入这里的生活，就好了。
到一个新的地方，无非也就是风土人情、衣食住行。</p>

<p>新加坡的环境不错，绿化很好，人也不多。
白天在路上走，也很容易找到遮阳的地方。
不过感觉道路规划比较奇怪，NUS 里面的山坡也很坑爹。
来之前以为有机会锻炼英语了，来了之后才发现 singlish 没啥好学习的，吃饭也会有人主动问“你要吃什么”。</p>

<p>坡上四季如夏，每天穿的都是短袖、短裤、凉鞋。
所以见到“不抽烟，少喝酒，天然发型，素色T恤或衬衣，休闲皮凉鞋”，不一定就是程序员。
这里的天气其实并不算很热，和上海夏天的平均温度差不多吧。
但室内常年开着空调，每次回到楼里都觉得很冷。
于是在实验室备了一件长袖，但目前为止还没用上。
来了之后赶上一次下雨，下着下着就没了，丝毫没有出现“交大游泳池”的迹象。
每天最晒的时候，应该是下午一两点的时候，我只经历过一次，此后就一直躲在屋里了。</p>

<p>然后说吃饭。
来了之后出去吃了一顿川菜、一顿烤鱼、一顿螃蟹，其他都是在食堂之类的地方解决。
川菜和烤鱼没什么不一样，螃蟹倒是别有风味，个头大，最特别的是钳子里的肉非常多。
在食堂等地方呢，就吃些普通的饭啊菜啊、馄饨啊饺子啊，目前为止还没吃过别样风味的菜品。
不过有一个问题，就是菜特别少，肉特别多。
来了之后只吃到过油菜和生菜，以及白菜叶类似物。
胡萝卜如果算菜的话就算进去好了。
相比肉类的丰富，蔬菜的缺少实在不能忍受。
上次吃碗牛肉面，居然还把花椒叶嚼了半天。
吃不到菜，就只能用水果来弥补。
但大街上只能看到卖榴莲的，苹果只在超市里找到了，还是从中国运过来的。</p>

<p>住的地方是一个三层小楼，我们三个人住在二楼的一间屋子里。
周围环境还不错，很安静，交通也还算方便。
据说我来之前可以看到蟑螂，不过来之后还没有遇到过。
据说寝室那边蟑螂已经泛滥了，不知道回去之后会是什么样子。
我离开学校之前，就已经每天在和蟑螂斗智斗勇了。</p>

<p>每天上班是坐公交车，到站之后就在校园里，走路不到十分钟就到实验室了。
这里公交是不报站的，乘客自己觉得快到站了就按铃，不然的话车就开过去了。
还好我每天上下车的两个站点都不算冷门，所以还没有坐过站的经历。
不过最开始不太熟悉学校里的环境，经常还没到站的时候就下车了，然后就要徒步熟悉各种坡度。
地铁的话，不经常坐，跟上海也没啥差别。</p>

<p>最后，上班和上学，感觉真是很不一样的。
特别是，别人还在上学的时候来上班，感觉就更不一样了。
不用上课，又没人查岗，每天就是坐在电脑前面，“做研究”。
回家也没什么特别的事情，累的时候就躺下，过一会儿再坐起来打字。
上班和下班的区别，就是写的程序内容不一样，但正在做的事情基本上都是写程序。
半个月，有了充足的时间打磨自己，隐约觉得有些进步，至少 vim 用得更熟练了。
略坑爹的是，戴尔的键盘满天下，虽然半个月已经熟悉了，可还是感觉键程太长，手指疲乏。</p>

<p>嗯，就写这么多吧。
自从语文不及格以来，写文章的能力越来越差，和码农功夫此消彼涨，甚是捉急啊。</p>
</div><footer class="entry-meta">This entry was posted on <a href="http://blog.xiao-jia.com/2012/09/17/two-weeks-sg/" rel="bookmark"><time class="entry-date" pubdate>September 17, 2012</time></a><span class="by-author"> by <span class="author vcard"><a class="url fn n" href="http://blog.xiao-jia.com" rel="author">Xiao Jia</a></span></span>&nbsp;&middot;&nbsp;<a href="http://blog.xiao-jia.com/tag/singapore/">singapore</a>&nbsp;&middot;&nbsp;<a href="http://blog.xiao-jia.com/tag/life/">life</a></footer></article><article class="post type-post status-publish format-standard hentry"><header class="entry-header"><h1 class="entry-title"><a href="http://blog.xiao-jia.com/2012/09/07/undocumented-erlang-internals/" rel="bookmark"> Why Erlang internals are undocumented</a></h1><a class="comments-link" href="http://blog.xiao-jia.com/2012/09/07/undocumented-erlang-internals/#disqus_thread">Comments</a></header><div class="entry-content"><p>I think it works like this:</p>

<p>1) first you don&#8217;t understand how the X works (X=Beam, JVM, X11, &#8230; you name it)</p>

<p>2) You struggle - and think - google and have a hot bath</p>

<p>3) Eureka - bath flows over</p>

<p>4) Now you can understand it - and you can also remember why you could not understand it</p>

<p>5) Now it&#8217;s easy you understand it</p>

<p>6) You see no reason to document it since it&#8217;s obvious</p>

<p>Round about 4) there is a small window of opportunity to explain to other people how it works. Once you get to 6) it&#8217;s very difficult to remember what it felt like at point 2) and consequently difficult to write decent documentation.</p>

<p>&#8211; Joe Armstrong</p>
</div><footer class="entry-meta">This entry was posted on <a href="http://blog.xiao-jia.com/2012/09/07/undocumented-erlang-internals/" rel="bookmark"><time class="entry-date" pubdate>September 7, 2012</time></a><span class="by-author"> by <span class="author vcard"><a class="url fn n" href="http://blog.xiao-jia.com" rel="author">Xiao Jia</a></span></span>&nbsp;&middot;&nbsp;<a href="http://blog.xiao-jia.com/tag/erlang/">erlang</a></footer></article><article class="post type-post status-publish format-standard hentry"><header class="entry-header"><h1 class="entry-title"><a href="http://blog.xiao-jia.com/2012/08/27/violet/" rel="bookmark"> Violet (The Architecture of Open Source Applications, Volume I)</a></h1><a class="comments-link" href="http://blog.xiao-jia.com/2012/08/27/violet/#disqus_thread">Comments</a></header><div class="entry-content"><p>原文链接：<a href="http://www.aosabook.org/en/violet.html">http://www.aosabook.org/en/violet.html</a><br/>
作者：<a href="http://www.aosabook.org/en/intro1.html#horstmann-cay">Cay Horstmann</a><br/>
译者：<a href="http://xiao-jia.com">Xiao Jia</a>（贾枭）</p>

<p>2002 年，我写了一本关于面向对象设计与模式的本科教材 [<a href="http://www.aosabook.org/en/bib1.html#bib:horstmann:oodp">Hor05</a>]。和很多书一样，这本书也源于我对经典课程的沮丧。一般来说，计算机科学专业的学生，会在他们的第一门编程课上，学习如何设计一个独立的类。而此后，直到在高年级的软件工程课中，他们才在面向对象设计方面接受更多的训练。在这门课程中，学生在几个星期内匆忙地学习 UML 和设计模式，最终也只是走马观花。我写的这本书是为一个学期的课程准备的，学生需要具备一些 Java 编程和基本数据结构的知识（通常这些知识来自基于 Java 的 CS1 或 CS2 课程安排）。这本书在学生所熟悉的上下文中涵盖了面向对象设计原则和设计模式的内容。比如用 Swing 里面的 <code>JScrollPane</code> 类来介绍修饰模式（Decorator Pattern），目的是希望这个例子比经典的 Java 流的例子①更容易让人记住。</p>

<blockquote>
<p>① 译者注：如 <code>FileInputStream</code> 和 <code>BufferedInputStream</code> 等。</p>
</blockquote>

<figure>
<img src="http://www.aosabook.org/images/violet/object-sample.png" alt="图 22.1：Violet 里的对象图（Object Diagram）" />
<figcaption>图 22.1：Violet 里的对象图（Object Diagram）</figcaption></figure>



<p>在这本书里，我需要一种轻量级的 UML，包括类图、顺序图，以及能够显示出 Java 对象引用的一种对象图（参见图 22.1）。我还想让学生能够绘制他们自己的UML图。然而，像 Rational Rose 这样的商业软件，不仅价格昂贵，还难以学习 [<a href="http://www.aosabook.org/en/bib1.html#bib:shumba:ratrose">Shu05</a>]。而在当时可用的开源替代品，则功能有限并且缺陷很多❶。比如需要使用文字来描述 UML 图，而不是使用更常见的点击式的界面。特别是 ArgoUML 软件中的顺序图，根本无法使用。</p>

<blockquote>
<p>❶ 当时我还不知道 Diomidis Spinellis 的令人钦佩的 UMLGraph 程序 [<a href="http://www.aosabook.org/en/bib1.html#bib:spinellis:umlgraph">Spi03</a>]</p>
</blockquote>

<p>于是我决定自己尝试去实现一个最简单的 UML 编辑器，它一要对学生有用，二要是一个可扩展的框架，便于学生理解和修改。就这样，Violet 诞生了。</p>

<h2 id="violet">22.1. 初识 Violet</h2>

<p>Violet 是一个轻量级的 UML 编辑器，适用于学生、教师，以及需要快速创建简单 UML 图的作者。它非常易于学习和使用。你可以用它绘制类图、顺序图、状态图、对象图和用例图。（至今，其他类型的 UML 图也已经有人贡献代码，实现了它们。）它是一个开放源代码并且跨平台的软件。Violet 的核心使用了一种简单而灵活的图形框架，该框架充分利用了 Java 2D 图形接口的优势。</p>

<p>Violet 的用户界面被故意设计得很简单。你不需要通过一系列单调乏味的对话框来输入属性和方法。相反，你只需要把它们输入到一个文本框中。只要点几下鼠标，你就能快速地创建出既吸引人又实用的 UML 图。</p>

<p>Violet 并不尝试去成为一个工业级的 UML 程序。下面是一些 Violet 不具备的特性：</p>

<ul>
<li>Violet 不能从 UML 图生成代码，也不能从代码生成 UML 图；</li>
<li>Violet 不会对模型进行语义检查，所以你可以绘制出自相矛盾的 UML 图；</li>
<li>Violet 生成的文件不能在其他UML工具中导入，它也不能读取其他工具产生的模型文件；</li>
<li>除了一些简单的功能如“自动对齐到网格”，Violet 不提供 UML 图的自动布局功能。</li>
</ul>

<p>（尝试列出一些这样的局限性，对学生项目会很有帮助。）</p>

<p>Violet 后来发展出一个由设计者构成的用户群体，他们想要一个比较正规的工具，但又不要像工业级的 UML 工具那么重量级。这时，我在 SourceForge 上以 GNU GPL 协议发布了代码。从 2005 年开始，Alexandre de Pellegrin 加入了这个项目，并提供了一个 Eclipse 插件和一个更加好看的用户界面。从那时起，他就开始进行很多架构上的改动。现在，他是这个项目的主要维护者。</p>

<p>在这篇文章里，我会讨论在 Violet 原本架构中的一些选择，以及它的演变。这篇文章会有一部分的重点是在图形编辑上，但其他几部分，比如 JavaBeans 属性的使用、持久化、Java WebStart、插件架构，这些应该都是大家所普遍感兴趣的。</p>

<h2 id="">22.2. 图形框架</h2>

<p>Violet 基于一个通用的图形编辑框架，这个框架能够渲染和编辑任意形状的节点和边。Violet UML 编辑器把类、对象、（顺序图中的）方法调用框（activation bar）等对应为节点，而把 UML 图中的各种线条形状对应为边。这个图形框架的另一实例则可以显示实体关系图（ER 图）或铁路图②。</p>

<blockquote>
<p>② 译者注：railroad diagram，又称语法图（syntax diagram），是形式文法的一种图形化表示方式。</p>
</blockquote>

<figure>
<img src="http://www.aosabook.org/images/violet/Ch8-06.png" alt="图 22.2：该图形编辑框架的一个简单实例" />
<figcaption>图 22.2：该图形编辑框架的一个简单实例</figcaption></figure>



<p>为了更好地解释这个框架，我们来考虑一个非常简单的图形编辑器，它包括黑色和白色的圆圈节点，以及直线边（参见图 22.2）。下面的 <code>SimpleGraph</code> 类定义了节点和边的原型对象（prototype objects），解释了什么是原型模式：</p>

<pre><code>public class SimpleGraph extends AbstractGraph
{
  public Node[] getNodePrototypes()
  {
    return new Node[]
    {
      new CircleNode(Color.BLACK),
      new CircleNode(Color.WHITE)
    };
  }
  public Edge[] getEdgePrototypes()
  {
    return new Edge[]
    {
      new LineEdge()
    };
  }
}
</code></pre>

<p>原型对象被用来绘制图 22.2 上方所示的节点和边的按钮。每当用户在图中添加一个新的节点或新的边，对应的原型对象就会被复制一份。上述代码中的 <code>Node</code>（节点）和 <code>Edge</code>（边）是具有下列关键方法的接口：</p>

<ul>
<li>两个接口都有一个 <code>getShape</code> 方法，用来返回一个 Java 2D 的 <code>Shape</code> 对象（分别是节点和边的形状）。</li>
<li><code>Edge</code> 接口具有用来在边的两端产生节点的方法。</li>
<li><code>Node</code> 接口中的 <code>getConnectionPoint</code> 方法负责计算出在节点边界上的一个最优的附着点（参见图 22.3）。</li>
<li><code>Edge</code> 接口中的 <code>getConnectionPoints</code> 方法负责产生这条边的两个端点。绘制当前被选中的边的两个可以拖动的端点的时候需要这个方法。</li>
<li>一个节点可以有一些跟随其自身移动的子节点。有很多方法就是用来枚举和管理这些子节点的。</li>
</ul>

<figure>
<img src="https://raw.github.com/stfairy/aosa-violet/master/Ch8-07.png" alt="图 22.3：在节点的边界上找一个连接点" />
<figcaption>图 22.3：在节点的边界上找一个连接点</figcaption></figure>



<p>辅助类 <code>AbstractNode</code> 和 <code>AbstractEdge</code> 实现了接口要求的大部分方法，而 <code>RectangularNode</code> 和 <code>SegmentedLineEdge</code> 两个类则提供了完整的实现，分别包括带有文字标题的矩形节点以及由线段构成的边。</p>

<p>对于我们的这个简单的图形编辑器，我们需要编写子类 <code>CircleNode</code> 和 <code>LineEdge</code>，来提供 <code>draw</code> 方法、<code>contains</code> 方法，以及描述节点边界形状的 <code>getConnectionPoint</code> 方法。它们的代码如下所示，同时，图 22.4 是由这些类构成的类图（当然，是用 Violet 绘制的）。</p>

<pre><code>public class CircleNode extends AbstractNode
{
  public CircleNode(Color aColor)
  {
    size = DEFAULT_SIZE;
    x = 0;
    y = 0;
    color = aColor;
  }

  public void draw(Graphics2D g2)
  {
    Ellipse2D circle = new Ellipse2D.Double(x, y, size, size);
    Color oldColor = g2.getColor();
    g2.setColor(color);
    g2.fill(circle);
    g2.setColor(oldColor);
    g2.draw(circle);
  }

  public boolean contains(Point2D p)
  {
    Ellipse2D circle = new Ellipse2D.Double(x, y, size, size);
    return circle.contains(p);
  }

  public Point2D getConnectionPoint(Point2D other)
  {
    double centerX = x + size / 2;
    double centerY = y + size / 2;
    double dx = other.getX() - centerX;
    double dy = other.getY() - centerY;
    double distance = Math.sqrt(dx * dx + dy * dy);
    if (distance == 0) return other;
    else return new Point2D.Double(
      centerX + dx * (size / 2) / distance,
      centerY + dy * (size / 2) / distance);
  }

  private double x, y, size, color;
  private static final int DEFAULT_SIZE = 20;
}

public class LineEdge extends AbstractEdge
{
  public void draw(Graphics2D g2)
  { g2.draw(getConnectionPoints()); }

  public boolean contains(Point2D aPoint)
  {
    final double MAX_DIST = 2;
    return getConnectionPoints().ptSegDist(aPoint) &lt; MAX_DIST;
  }
}
</code></pre>

<figure>
<img src="http://www.aosabook.org/images/violet/SimpleGraph-in-Violet.png" alt="图 22.4：简单图形编辑器的类图" />
<figcaption>图 22.4：简单图形编辑器的类图</figcaption></figure>



<p>总的来说，Violet 为编写图形编辑器提供了一个简单的框架。通过定义节点和边所对应的类，并在图形类中提供产生节点和边的原型对象的方法，就可以得到一个编辑器的实例。</p>

<p>当然，还有其他图形框架可以使用，比如 JGraph [<a href="http://www.aosabook.org/en/bib1.html#bib:alder:jgraph">Ald02</a>] 和 JUNG ❷。然而，这些框架都相当复杂，提供的也只是“用来绘制图形”的框架，而不是“用来绘制图形的应用程序”的框架。</p>

<blockquote>
<p>❷ <a href="http://jung.sourceforge.net">http://jung.sourceforge.net</a></p>
</blockquote>

<h2 id="javabeans">22.3. JavaBeans 属性的使用</h2>

<p>在客户端 Java 的鼎盛时期，人们制定了 JavaBeans 规范，用来给在可视化 GUI 设计环境里编辑 GUI 组件提供可移植的机制。其目的是为了让一个第三方的 GUI 组件可以放在任意的 GUI 设计器中，并且它的属性可以像按钮、文本等标准组件一样进行设置。</p>

<p>Java 语言本身没有对属性的原生支持。JavaBeans 属性可以从成对的 getter 和 setter 方法中发现出来，或者通过相应的 <code>BeanInfo</code> 类指定。进一步地，可以指定 <em>属性编辑器</em> 来可视化地编辑属性的值。JDK 甚至包含了一些基本的属性编辑器，比如用来编辑 <code>java.awt.Color</code> 类型的编辑器。</p>

<p>Violet 框架充分利用了 JavaBeans 规范。比如，<code>CircleNode</code> 类可以通过提供如下两个方法，来暴露出颜色这一属性：</p>

<pre><code>public void setColor(Color newValue)
public Color getColor()
</code></pre>

<p>现在，不需要任何额外的工作，这个图形编辑器就能编辑圆圈节点的颜色了（参见图 22.5）。</p>

<figure>
<img src="http://www.aosabook.org/images/violet/Ch8-11.png" alt="图 22.5：使用默认的 JavaBeans 颜色编辑器来编辑圆圈节点的颜色" />
<figcaption>图 22.5：使用默认的 JavaBeans 颜色编辑器来编辑圆圈节点的颜色</figcaption></figure>



<h2 id="">22.4. 长期的持久化</h2>

<p>和任何编辑器一样，Violet 需要将用户创建的 UML 图保存到文件中，并在之后重新载入进来。人们设计了 XMI 标准❸，作为 UML 模型的一种公共交换格式。我在看过 XMI 标准后，觉得它非常蹩脚，难以理解和使用。我想我并非唯一有这种感受的人——XMI 以极差的互操作性出名，即使对于最简单的模型也是如此 [<a href="http://www.aosabook.org/en/bib1.html#bib:persson:osstools">PGL+05</a>]。</p>

<blockquote>
<p>❸ <a href="http://www.omg.org/technology/documents/formal/xmi.htm">http://www.omg.org/technology/documents/formal/xmi.htm</a></p>
</blockquote>

<p>我曾考虑过直接使用 Java 的序列化（serialization）功能，但在实现经常有改动的情况下，读取旧版本的序列化后的对象非常困难。JavaBeans 的架构师们同样预见到了这一问题，于是他们为长期的持久化开发了一套标准的 XML 格式❹。一个 Java 对象（比如 Violet 里的 UML 图）会被序列化成一串语句，这些语句描述了创建和修改这个对象的过程。比如：</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;java version=&quot;1.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;
 &lt;object class=&quot;com.horstmann.violet.ClassDiagramGraph&quot;&gt;
  &lt;void method=&quot;addNode&quot;&gt;
   &lt;object id=&quot;ClassNode0&quot; class=&quot;com.horstmann.violet.ClassNode&quot;&gt;
    &lt;void property=&quot;name&quot;&gt;…&lt;/void&gt;
   &lt;/object&gt;
   &lt;object class=&quot;java.awt.geom.Point2D$Double&quot;&gt;
    &lt;double&gt;200.0&lt;/double&gt;
    &lt;double&gt;60.0&lt;/double&gt;
   &lt;/object&gt;
  &lt;/void&gt;
  &lt;void method=&quot;addNode&quot;&gt;
   &lt;object id=&quot;ClassNode1&quot; class=&quot;com.horstmann.violet.ClassNode&quot;&gt;
    &lt;void property=&quot;name&quot;&gt;…&lt;/void&gt;
   &lt;/object&gt;
   &lt;object class=&quot;java.awt.geom.Point2D$Double&quot;&gt;
    &lt;double&gt;200.0&lt;/double&gt;
    &lt;double&gt;210.0&lt;/double&gt;
   &lt;/object&gt;
  &lt;/void&gt;
  &lt;void method=&quot;connect&quot;&gt;
   &lt;object class=&quot;com.horstmann.violet.ClassRelationshipEdge&quot;&gt;
    &lt;void property=&quot;endArrowHead&quot;&gt;
     &lt;object class=&quot;com.horstmann.violet.ArrowHead&quot; field=&quot;TRIANGLE&quot;/&gt;
    &lt;/void&gt;
   &lt;/object&gt;
   &lt;object idref=&quot;ClassNode0&quot;/&gt;
   &lt;object idref=&quot;ClassNode1&quot;/&gt;
  &lt;/void&gt;
 &lt;/object&gt;
&lt;/java&gt;
</code></pre>

<blockquote>
<p>❹ <a href="http://jcp.org/en/jsr/detail?id=57">http://jcp.org/en/jsr/detail?id=57</a></p>
</blockquote>

<p>当 <code>XMLDecoder</code> 类读取这个文件的时候，它会按顺序执行这些语句（为方便起见，包名已省略）。</p>

<pre><code>ClassDiagramGraph obj1 = new ClassDiagramGraph();
ClassNode ClassNode0 = new ClassNode();
ClassNode0.setName(…);
obj1.addNode(ClassNode0, new Point2D.Double(200, 60));
ClassNode ClassNode1 = new ClassNode();
ClassNode1.setName(…);
obj1.addNode(ClassNode1, new Point2D.Double(200, 60));
ClassRelationShipEdge obj2 = new ClassRelationShipEdge();
obj2.setEndArrowHead(ArrowHead.TRIANGLE);
obj1.connect(obj2, ClassNode0, ClassNode1);
</code></pre>

<p>只要这些构造函数、属性和方法的语义没有改变，新版本的程序就能够读取旧版本程序生成的文件。</p>

<p>生成这样的文件非常直观。编码器（encoder）自动地枚举每个对象的属性，对于那些不同于默认值的属性，编码器会为这些属性输出设置属性值的语句。Java 平台处理了大部分基本数据类型，然而我需要特殊处理 <code>Point2D</code>、<code>Line2D</code> 和 <code>Rectangle2D</code> 这三个类。更重要的是，编码器需要知道，一个图形可以被序列化成一串对 <code>addNode</code> 和 <code>connect</code> 方法的调用：</p>

<pre><code>encoder.setPersistenceDelegate(Graph.class, new DefaultPersistenceDelegate()
{
  protected void initialize(Class&lt;?&gt; type, Object oldInstance,
    Object newInstance, Encoder out)
  {
    super.initialize(type, oldInstance, newInstance, out);
    AbstractGraph g = (AbstractGraph) oldInstance;
    for (Node n : g.getNodes())
      out.writeStatement(new Statement(oldInstance, &quot;addNode&quot;, new Object[]
      {
        n,
        n.getLocation()
      }));
    for (Edge e : g.getEdges())
      out.writeStatement(new Statement(oldInstance, &quot;connect&quot;, new Object[]
      {
        e, e.getStart(), e.getEnd()
      }));
  }
});
</code></pre>

<p>一旦配置好编码器，保存一个图形就变得非常简单了：</p>

<pre><code>encoder.writeObject(graph);
</code></pre>

<p>因为解码器（decoder）只是简单地执行语句，所以不需要额外的配置。可以像下面这样读取一个图形：</p>

<pre><code>Graph graph = (Graph) decoder.readObject();
</code></pre>

<p>在 Violet 经过了许许多多版本的过程中，这个方法一直工作得相当好。但是有一次例外：最近的一次重构改变了一些包的名字，因此破坏了向后兼容性。一种选择是，仍然保留旧包中的那些类，即使它们和新的包结构已经不再匹配。然而，维护者没有这样做，而是提供了一个 XML 转换器，用来在读取旧版本文件的时候改写包名。</p>

<h2 id="javawebstart">22.5. Java WebStart</h2>

<p>Java WebStart 是用来在网页浏览器中启动应用程序的一门技术。部署者发布一个 JNLP 文件③，该文件在浏览器中会触发一个辅助程序，该程序会下载并运行相应的 Java 应用程序。应用程序可以是数字签名过的，此时用户必须同意接受其证书；或者程序是未签名的，此时它只能运行在一个比 applet 沙盒权限稍高的沙盒环境中。</p>

<blockquote>
<p>③ 译者注：JNLP 即 Java Network Launching Protocol。</p>
</blockquote>

<p>我不认为终端用户有能力判断数字证书的有效性及其暗含的安全性。Java 平台长处之一就是它的安全性，而我觉得发挥这一长处是很重要的。</p>

<p>Java WebStart 沙盒已经足够强大了，它可以支持用户进行很多有用的工作，包括读取和保存文件，以及打印。这些操作都从用户的角度保证了安全性和易用性。当应用程序想要访问本地文件系统时，会弹出对话框提示用户，并由用户来选择可以被读写的文件。应用程序仅能得到一个用于读写文件的流对象，而在文件选择的过程中，没有任何机会窥探到文件系统的情况。</p>

<p>让人讨厌的是，在 WebStart 下运行时，开发者必须自己编写代码来和 <code>FileOpenService</code> 以及 <code>FileSaveService</code> 进行交互。更讨厌的是，没有一个 WebStart 接口调用，可以知道应用程序是否是由 WebStart 启动的。</p>

<p>类似地，保存用户的使用偏好也必须以两种方式来实现：当应用程序正常运行时，使用 Java 偏好接口（Java Preferences API）；当应用程序在 WebStart 下运行时，使用 WebStart 偏好服务（WebStart Preferences Service）。然而，打印功能对于应用开发者来说则是完全透明的④。</p>

<blockquote>
<p>④ 译者注：即正常运行和在 WebStart 下运行时，不需要以不同的方式来实现。</p>
</blockquote>

<p>Violet 在这些服务之上提供了简单的抽象层，以减轻应用开发者的负担。比如，下面是一个打开文件的例子：</p>

<pre><code>FileService service = FileService.getInstance(initialDirectory);
  // 检查我们是否正在 WebStart 下运行
FileService.Open open = fileService.open(defaultDirectory, defaultName,
  extensionFilter);
InputStream in = open.getInputStream();
String title = open.getName();
</code></pre>

<p><code>FileService.Open</code> 接口有两个实现类：一个是对 <code>JFileChooser</code> 的封装，另一个则是 JNLP 的 <code>FileOpenService</code>。</p>

<p>JNLP 接口本身并非如此方便；在其生命周期里，很少有人喜欢它，以至于它基本上已经被大家忽略了。大多数的项目直接为其 WebStart 应用程序使用可一个自己签名的证书，而对于用户来说，这毫无安全性可言。这是一种耻辱——开源开发者应该拥护 JNLP 沙盒，把它作为尝试新项目的一种零风险的方式。</p>

<h2 id="java2d">22.6. Java 2D</h2>

<p>Violet 大量使用了 Java 2D；它是 Java API（应用程序接口）中鲜为人知的珍宝。每个节点和边都有一个 <code>getShape</code> 方法，返回一个 <code>java.awt.Shape</code> 接口的对象。这个接口是 Java 2D 中所有形状的公共接口，矩形、圆形、路径，以及它们的并、交和差，都实现了这一接口。如果要创建由任意线段和二次/三次曲线段构成的图形，比如直箭头和弯箭头，<code>GeneralPath</code> 类就很有用。</p>

<p>考虑下面这段绘制阴影的代码（摘自 <code>AbstractNode.draw</code> 方法），从中我们可以欣赏到 Java 2D 接口的灵活之美：</p>

<pre><code>Shape shape = getShape();
if (shape == null) return;
g2.translate(SHADOW_GAP, SHADOW_GAP);
g2.setColor(SHADOW_COLOR);
g2.fill(shape);
g2.translate(-SHADOW_GAP, -SHADOW_GAP);
g2.setColor(BACKGROUND_COLOR);
g2.fill(shape);
</code></pre>

<p>只需要几行代码，就可以为任意的形状产生阴影，甚至包括开发者在后来才加入的形状。</p>

<p>当然，Violet 能以任何格式保存位图图像，只要 <code>javax.imageio</code> 这个包支持，比如 GIF、PNG、JPEG，等等。当我的出版商要我提供矢量图形的时候，我注意到了 Java 2D 的另一个好处。当你打印到一个 PostScript 打印机的时候，Java 2D 操作会被翻译成 PostScript 矢量绘图操作。如果你打印到一个文件，输出的文件可以使用 <code>ps2eps</code> 这样的程序处理，进而导入到 Adobe Illustrator 或 Inkscape 中。下面是相关的代码（这里 <code>comp</code> 是一个 Swing 组件，它的 <code>paintComponent</code> 方法打印上述图形）：</p>

<pre><code>DocFlavor flavor = DocFlavor.SERVICE_FORMATTED.PRINTABLE;
String mimeType = &quot;application/postscript&quot;;
StreamPrintServiceFactory[] factories;
StreamPrintServiceFactory.lookupStreamPrintServiceFactories(flavor, mimeType);
FileOutputStream out = new FileOutputStream(fileName);
PrintService service = factories[0].getPrintService(out);
SimpleDoc doc = new SimpleDoc(new Printable() {
  public int print(Graphics g, PageFormat pf, int page) {
    if (page &gt;= 1) return Printable.NO_SUCH_PAGE;
    else {
      double sf1 = pf.getImageableWidth() / (comp.getWidth() + 1);
      double sf2 = pf.getImageableHeight() / (comp.getHeight() + 1);
      double s = Math.min(sf1, sf2);
      Graphics2D g2 = (Graphics2D) g;
      g2.translate((pf.getWidth() - pf.getImageableWidth()) / 2,
              (pf.getHeight() - pf.getImageableHeight()) / 2);
      g2.scale(s, s);

      comp.paint(g);
      return Printable.PAGE_EXISTS;
    }
  }
}, flavor, null);
DocPrintJob job = service.createPrintJob();
PrintRequestAttributeSet attributes = new HashPrintRequestAttributeSet();
job.print(doc, attributes);
</code></pre>

<p>开始的时候，我还在担心使用通用的形状（general shapes）会影响性能，但事实证明并非如此。裁剪功能（clipping）工作得很好，只有那些更新当前视图（viewport）的形状操作才会被执行。</p>

<h2 id="swing">22.7. 不使用 Swing 应用程序框架</h2>

<p>大多数 GUI 框架都有一个类似“应用程序”的概念，它负责管理一组文档，一个文档则负责处理菜单、工具栏、状态栏，等等。然而，Java API 中从来没有这个概念。JSR 296 ❺的提出，目的是为 Swing 应用程序提供一个基本的框架，但目前它已经处于闲置状态了。因此，Swing 应用程序的作者有两种选择，要么“重新发明轮子”⑤，要么依靠一个第三方的框架。在编写 Violet 的时候，应用程序框架的主流选择是 Eclipse 和 NetBeans 平台，但当时它们看上去都太重量级了。（现如今我们有更多的选择了，比如 GUTS ❻，它是 JSR 296 的一个分支。）因此，Violet 被迫重新发明了处理菜单和内部框架（internal frames）的机制。</p>

<blockquote>
<p>❺ <a href="http://jcp.org/en/jsr/detail?id=296">http://jcp.org/en/jsr/detail?id=296</a><br/>
❻ <a href="http://kenai.com/projects/guts">http://kenai.com/projects/guts</a></p>

<p>⑤ 译者注：reinvent the wheel，指对一些基本或常见的问题，不采纳现有的成熟的方案。</p>
</blockquote>

<p>在 Violet 中，你可以像下面这样，在属性文件（property files）中指定菜单项：</p>

<pre><code>file.save.text=Save
file.save.mnemonic=S
file.save.accelerator=ctrl S
file.save.icon=/icons/16x16/save.png
</code></pre>

<p>有一个工具方法从前缀（比如这里的 <code>file.save</code>）创建菜单项。<code>.text</code>、<code>.mnemonic</code>这样的后缀，在今天一般被称作“约定优于配置”。使用资源文件来描述这些设置，显然要比调用 API 来建立菜单高级得多，因为这让本地化（localization）变得十分简单。我在另一个开源项目 GridWorld ❼中重用了这一机制，它是一个高中计算机科学教学的环境。</p>

<blockquote>
<p>❼ <a href="http://horstmann.com/gridworld">http://horstmann.com/gridworld</a></p>
</blockquote>

<p>Violet 这样的应用程序，都允许用户打开多个文档，每个文档包含一个图形。最初编写 Violet 的时候，多文档接口（MDI，multiple document interface）还很流行。使用 MDI 时，主框架（main frame）有一个菜单栏，而每个文档的视图显示在一个内部框架中，这个内部框架有标题栏但是没有菜单栏。每个内部框架都被包含在主框架中，用户可以修改它的大小，或者最小化它。此外，还有操作用于层叠或平铺窗口。</p>

<p>很多开发者不喜欢 MDI，因此这种风格的用户界面已经过时了。单文档接口（SDI，single document interface）的应用程序则显示很多顶层的框架。一段时间里，SDI 被认为更加高级，大概是因为可以使用宿主操作系统的标准窗口管理工具来操作这些顶层框架。当人们最终意识到太多的顶层窗口也不是很方便的时候，标签页界面（tabbed interfaces）出现了。标签页界面中，多个文档再次被放到一个单个的框架中，但每个都是以完整大小显示的，并且可以通过标签（tabs）来选择。这种界面不允许用户并排比较两个文档，但看起来还是胜出了。</p>

<p>Violet 最初使用的是 MDI。Java API 包含了内部框架这一特性，但我需要增加对平铺和层叠窗口的支持。Alexandre 切换到了标签页界面；从某种程度上来说，这种界面在 Java API 中得到了更好的支持。在应用程序框架中，如果文档的显示策略对于开发者是透明的，或许是可以让用户来选择的，那将是非常可取的。</p>

<p>Alexandre 还增加了对侧边栏、状态栏、欢迎面板、启动闪屏的支持。理想情况下，所有这些都应该是 Swing 应用程序框架所支持的。</p>

<h2 id="undoredo">22.8. 撤消（undo）和重做（redo）</h2>

<p>实现多次撤消和重做，看起来是一件令人怯步的任务，但 Swing 的撤销功能包（undo package，[<a href="http://www.aosabook.org/en/bib1.html#bib:topley:coreswing">Top00</a>]，第九章）给出了一个很好的架构上的指南。一个 <code>UndoManager</code>（撤消管理器）管理一个 <code>UndoableEdit</code>（可撤消的编辑）对象的栈（stack）。这里面的每一个对象，都有一个 <code>undo</code> 方法负责撤消该编辑操作的作用，还有一个 <code>redo</code> 方法负责重做该编辑操作（恢复效果）。一个 <code>CompoundEdit</code>（复合编辑）是一串 <code>UndoableEdit</code> 操作，它们可以作为一个整体被撤消或重做。我们鼓励你定义小的、原子的（atomic）编辑操作（比如在一个图里增加或删除一条边或一个节点），而这些操作可以按需被组织成一个复合的编辑操作。</p>

<p>随之而来的一个挑战就是如何定义一个小的原子操作集合，使得其中每个操作都容易撤消。Violet 中有如下几种原子操作：</p>

<ul>
<li>增加或删除一个节点或一条边</li>
<li>附着（attach）或拆开（detach）一个节点的子节点</li>
<li>移动一个节点</li>
<li>改变节点或边的属性</li>
</ul>

<p>上述每种操作都有一个很显然的撤消方法。比如，“增加一个节点”的撤消方法就是删掉这个节点，“移动一个节点”的撤消方法就是按相反的向量移动这个节点。</p>

<figure>
<img src="http://www.aosabook.org/images/violet/undo.png" alt="图 22.6：撤消操作必须撤消模型中的结构化的更改" />
<figcaption>图 22.6：撤消操作必须撤消模型中的结构化的更改</figcaption></figure>



<p>注意，这些原子操作<strong>不同于</strong>用户界面中的那些动作，或者是这些动作所调用的 <code>Graph</code> 接口的方法。比如，考虑图 22.6 中的顺序图，假设用户从左侧的方法调用框拖动鼠标到右侧的对象生命线，当鼠标被松开时，下面的方法会被调用：</p>

<pre><code>public boolean addEdgeAtPoints(Edge e, Point2D p1, Point2D p2)
</code></pre>

<p>这个方法会增加一条边，但它也可能根据具体参与调用的 <code>Edge</code> 和 <code>Node</code> 子类，进行其他操作。在这个例子中，右侧的对象生命线会增加一个新的方法调用框，那么撤消这一操作的时候，这个新的方法调用框也要被删掉。因此，模型（此例中的图形）还需要记录所需撤消的结构化的更改，而仅仅记录控制器（controller）中的操作是不够的。</p>

<p>正如 Swing 的撤销功能包所预想的，在发生一个结构化的更改时，图形、节点、边的这些类需要向 <code>UndoManager</code> 发送 <code>UndoableEditEvent</code>（可撤消的编辑事件）通知。Violet 具有一个更加通用的设计——图形自身为如下接口管理监听器（listeners）：</p>

<pre><code>public interface GraphModificationListener
{
  void nodeAdded(Graph g, Node n);
  void nodeRemoved(Graph g, Node n);
  void nodeMoved(Graph g, Node n, double dx, double dy);
  void childAttached(Graph g, int index, Node p, Node c);
  void childDetached(Graph g, int index, Node p, Node c);
  void edgeAdded(Graph g, Edge e);
  void edgeRemoved(Graph g, Edge e);
  void propertyChangedOnNodeOrEdge(Graph g, PropertyChangeEvent event);
}
</code></pre>

<p>Violet 框架在每个图形中安装一个监听器，作为与撤消管理器交互的桥梁。对于支持撤消功能来说，为模型增加通用的监听器支持是有点过度设计了（overdesigned）——图形操作可以直接与撤销管理器交互。然而，我还想支持一种实验性质的协作式编辑特性（collaborative editing feature）。</p>

<p>如果你想在你的应用程序中支持撤消和重做，仔细想想你的模型（而非你的界面）中的原子操作。在模型中，当发生结构化的改变时，触发相应的事件，并允许 Swing 的撤销管理器来收集、组合这些事件。</p>

<h2 id="">22.9. 插件架构</h2>

<p>对于熟悉 2D 图形编程的程序员来说，为 Violet 增加新类型的图并不困难。比如，活动图就是由第三方贡献开发的。当我需要创建铁路图和 ER 图的时候，我发现给 Violet 写一个扩展，要比胡乱使用 Visio 或 Dia 来得更快。（每种类型的图需要花一天的时间来实现。）</p>

<p>这些实现并不要求你理解整个 Violet 框架。只需要实现图形、节点和边的接口即可。为了让贡献开发者更容易地脱离 Violet 框架的演变过程，我设计了一个简单的插件架构。</p>

<p>当然，很多程序都有一个插件架构，其中的很多都说明详尽、实现精巧。当有人建议说 Violet 应该支持 OSGi 的时候，我打了个哆嗦，然后实现了能够让插件机制工作的最简单的事情。</p>

<p>贡献开发者只需要生成一个包含了图形、节点和边的实现的 JAR 文件，并把它放到 <code>plugins</code> 目录中。当 Violet 启动时，它会用 Java 的 <code>ServiceLoader</code>（服务加载器）类加载这些插件。<code>ServiceLoader</code> 类是用来加载像 JDBC 驱动这样的服务的。<code>ServiceLoader</code> 会加载那些能够对指定接口提供实现的 JAR 文件（比如这里的 <code>Graph</code> 接口）。</p>

<p>每个 JAR 文件必须包含一个名为 <code>META-INF/services</code> 的子目录，该目录中需要包含一个以相应接口的全称命名的文件（比如 <code>com.horstmann.violet.Graph</code>），文件内容是实现了这一接口的所有类的名字，每行一个。<code>ServiceLoader</code> 会为插件目录构造一个类加载器（class loader），并加载所有的插件：</p>

<pre><code>ServiceLoader&lt;Graph&gt; graphLoader = ServiceLoader.load(Graph.class, classLoader);
for (Graph g : graphLoader) // ServiceLoader&lt;Graph&gt;实现了Iterable&lt;Graph&gt;这个接口
  registerGraph(g);
</code></pre>

<p>这是标准 Java 中的一个简单而实用的设施；你或许会在你自己的项目中发现它的价值。</p>

<h2 id="">22.10. 总结</h2>

<p>和很多开源项目一样，Violet 诞生于未被满足的需求，即以最小的混乱代价，来绘制简单的 UML 图。Java SE 平台令人惊奇的广泛应用成就了 Violet。同时，Violet 也利用了该平台中的很多技术。在这篇文章中，我描述了 Violet 如何利用 JavaBeans、长期的持久化、Java WebStart、Java 2D、Swing 撤消和重做，以及服务加载器设施。这些技术并不总是和基础的 Java 及 Swing 一样容易被人理解，但它们可以极大地简化桌面应用程序的架构。它们让我能够在最开始作为一个独立的开发者，在几个月的业余时间里创建出一个成功的应用程序。依赖这些标准的机制，也让其他人改进 Violet，或是从中提取一些片段利用在他们自己的项目中，变得更加容易。</p>
</div><footer class="entry-meta">This entry was posted on <a href="http://blog.xiao-jia.com/2012/08/27/violet/" rel="bookmark"><time class="entry-date" pubdate>August 27, 2012</time></a><span class="by-author"> by <span class="author vcard"><a class="url fn n" href="http://blog.xiao-jia.com" rel="author">Xiao Jia</a></span></span>&nbsp;&middot;&nbsp;<a href="http://blog.xiao-jia.com/tag/工程/">工程</a>&nbsp;&middot;&nbsp;<a href="http://blog.xiao-jia.com/tag/翻译/">翻译</a></footer></article><article class="post type-post status-publish format-standard hentry"><header class="entry-header"><h1 class="entry-title"><a href="http://blog.xiao-jia.com/2012/04/20/sudoku/" rel="bookmark"> 零知识证明：数独</a></h1><a class="comments-link" href="http://blog.xiao-jia.com/2012/04/20/sudoku/#disqus_thread">Comments</a></header><div class="entry-content"><p>数独是一个非常有趣的游戏，印象里高中时候花了很多时间玩数独。现在的问题是，有一个非常难的数独，A想向B证明A解出了这个数独，但又不想让B知道关于这个解的任何信息。</p>

<p>如果可以让B知道解的信息，A可以直接把这个数独的解公开，B则按照数独的规则去检验这个解是否符合要求。如果不能让B知道关于解的任何信息，那么B就只知道数独的规则。</p>

<p>解决这个问题的办法是，A拿写有1&#8211;9的数字卡片各9张，将它们摆在桌面上。对于在数独题面中已经给出数字的格子，直接将卡片写有数字的一面朝上。对于是A解出的那些格子，把卡片写有数字的一面朝下。B也可以看到这个桌面上的卡片，并且按照A的摆放规则，B可以看到这个数独确实是那个非常难的数独。然后，B任意指定一行、一列或者一个3x3大小的方格，A当着B的面，将这选定的9张卡片拿出来，数字朝下并打乱顺序，然后翻开，让B检查。如果A提供的解是正确的话，那么这9张卡片翻开后一定是1&#8211;9这9个数字。如果A并没有解出这个数独，那么这9张卡片翻开后，不一定恰好是1&#8211;9这9个数字。B检查后，A再按照最初的摆放规则，将卡片恢复原位。在这一过程中，B只获知一件事情，就是刚刚指定的9个数字是正确的，而这仅仅是数独规则的一部分。随后，A和B继续这个过程，直至B检查完所有的行、列以及3x3大小的方格。整个过程中，B只是逐渐确信A的确解出了这个数独，但由于每次卡片是混乱着交给B来检查的，所以B并不知道这些卡片对应于解的哪些位置。这样一来，A就向B证明了自己解出了这个数独，同时，B也不知道这个解到底是怎样的。</p>

<p>整个过程中，需要确认一些细节，它们对理解会有帮助：</p>

<ol>
<li>A展示给B的数独，确实是那个非常难的数独，而不是其他的数独</li>
<li>每次翻开卡片并放回，都只涉及这9张卡片，这保证了没有在中途更改数独，并且B只能知道这9张是没有问题的</li>
<li>由于数独一直是同一个，所以B检查完所有行、列以及3x3大小的方格后，就可以确信这个解一定是正确的，同时B也只知道这个解是正确的，而不知道更多信息</li>
</ol>

<p>这个解决办法，就是<a href="http://baike.baidu.com/view/1228083.htm">零知识证明</a>的一个例子。零知识证明是一个非常有意思的话题，不需要什么背景知识，老少咸宜，如果有可能，我打算多写写这方面的东西。</p>
</div><footer class="entry-meta">This entry was posted on <a href="http://blog.xiao-jia.com/2012/04/20/sudoku/" rel="bookmark"><time class="entry-date" pubdate>April 20, 2012</time></a><span class="by-author"> by <span class="author vcard"><a class="url fn n" href="http://blog.xiao-jia.com" rel="author">Xiao Jia</a></span></span>&nbsp;&middot;&nbsp;<a href="http://blog.xiao-jia.com/tag/零知识证明/">零知识证明</a></footer></article><article class="post type-post status-publish format-standard hentry"><header class="entry-header"><h1 class="entry-title"><a href="http://blog.xiao-jia.com/2012/04/19/initial-commit/" rel="bookmark"> Initial commit</a></h1><a class="comments-link" href="http://blog.xiao-jia.com/2012/04/19/initial-commit/#disqus_thread">Comments</a></header><div class="entry-content"><p>思来想去，觉得还是应该继续写博客。思来想去，却选择了这样一个标题。不过，我将要在这里记叙的，一定不是技术，而是思考或是思维过程，甚至还有些许诡辩和谬误。嗯，“随便想想”嘛。</p>

<p>自上大学以来，就彻底远离了写文章，不仅是我，身边的人大概也是这样。我不清楚，这是该归咎于“快餐文化”的影响，还是源于我们自身成长带来的改变。有句话不是说，“我们都可耻地成熟了”么？</p>

<p>其实不写文章，并不代表没有什么可写的。从我自己来看，不写文章大概是因为时间紧、文笔差、读者少，但平时确实经常会有一些想法，想要以某种方式记录下来。脑子里的东西多半都是转瞬即逝，没能记下来的也就那么没掉了，要是再不开始记的话，就会没掉更多。我觉得人类的进步，很大程度上可以归功于思维的记录。子孙们肯定会和爷爷们遇到同样的问题，如果都重新想一遍的话，世世代代就毫无区别了。只有前人把这些思维过程以文字的形式记录下来，后人才能够长久地延续、发展。既然整个人类是这样，一个人也应该是这样的吧。记下自己点点滴滴的思绪，作为一种积累，算是件很有意义的事吧？</p>
</div><footer class="entry-meta">This entry was posted on <a href="http://blog.xiao-jia.com/2012/04/19/initial-commit/" rel="bookmark"><time class="entry-date" pubdate>April 19, 2012</time></a><span class="by-author"> by <span class="author vcard"><a class="url fn n" href="http://blog.xiao-jia.com" rel="author">Xiao Jia</a></span></span>&nbsp;&middot;&nbsp;<a href="http://blog.xiao-jia.com/tag/未分类/">未分类</a></footer></article><script async="async" src="http://xjia.disqus.com/count.js"></script></div>
      </div><!-- #primary -->
      <div id="secondary" class="widget-area" role="complementary"><aside id="recent-posts" class="widget widget_recent_entries"><h3 class="widget-title">Recent Posts</h3><ul><li><a href="http://blog.xiao-jia.com/2012/10/08/one-month-sg/"> @sg (2)</a></li><li><a href="http://blog.xiao-jia.com/2012/09/21/liangalei-stories/"> 听阿磊讲故事</a></li><li><a href="http://blog.xiao-jia.com/2012/09/17/two-weeks-sg/"> @sg (1)</a></li><li><a href="http://blog.xiao-jia.com/2012/09/07/undocumented-erlang-internals/"> Why Erlang internals are undocumented</a></li><li><a href="http://blog.xiao-jia.com/2012/08/27/violet/"> Violet (The Architecture of Open Source Applications, Volume I)</a></li><ul></aside><aside id="archives" class="widget widget_archive"><h3 class="widget-title">Archives</h3><ul><li><a href="http://blog.xiao-jia.com/2012/10/" title="October 2012">October 2012 (1)</a></li><li><a href="http://blog.xiao-jia.com/2012/09/" title="September 2012">September 2012 (3)</a></li><li><a href="http://blog.xiao-jia.com/2012/08/" title="August 2012">August 2012 (1)</a></li><li><a href="http://blog.xiao-jia.com/2012/04/" title="April 2012">April 2012 (2)</a></li><li><a href="http://blog.xiao-jia.com/2009/04/" title="April 2009">April 2009 (1)</a></li></ul></aside><aside id="categories" class="widget widget_categories"><h3 class="widget-title">Tags</h3><ul><li class="cat-item"><a href="http://blog.xiao-jia.com/tag/erlang/">erlang</a></li><li class="cat-item"><a href="http://blog.xiao-jia.com/tag/game/">game</a></li><li class="cat-item"><a href="http://blog.xiao-jia.com/tag/life/">life</a></li><li class="cat-item"><a href="http://blog.xiao-jia.com/tag/singapore/">singapore</a></li><li class="cat-item"><a href="http://blog.xiao-jia.com/tag/好玩的/">好玩的</a></li><li class="cat-item"><a href="http://blog.xiao-jia.com/tag/工程/">工程</a></li><li class="cat-item"><a href="http://blog.xiao-jia.com/tag/很久以前/">很久以前</a></li><li class="cat-item"><a href="http://blog.xiao-jia.com/tag/故事/">故事</a></li><li class="cat-item"><a href="http://blog.xiao-jia.com/tag/未分类/">未分类</a></li><li class="cat-item"><a href="http://blog.xiao-jia.com/tag/翻译/">翻译</a></li><li class="cat-item"><a href="http://blog.xiao-jia.com/tag/读书笔记/">读书笔记</a></li><li class="cat-item"><a href="http://blog.xiao-jia.com/tag/零知识证明/">零知识证明</a></li></ul></aside></div>
    </div><!-- #main .wrapper -->
    <footer id="colophon" role="contentinfo">
      <div class="site-info">
        Copyright &copy; 2012 <a href="http://blog.xiao-jia.com">Xiao Jia</a> &middot;
        Themed by <a href="http://theme.wordpress.com/themes/twentytwelve/">Twenty Twelve</a> &middot;
        Powered by <a href="https://github.com/stfairy/markpress" rel="generator">markpress</a>
      </div><!-- .site-info -->
    </footer><!-- #colophon -->
  </div><!-- #page -->
  <a href="https://github.com/stfairy/markpress"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png" alt="Fork me on GitHub"></a>
<script async="async" type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7475348-6']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
